# Skeleton-Aware Stroke Refitting in Web-Demo

## Overview

The web-demo now includes support for skeleton-aware stroke refitting through `refit_stroke_with_skeleton_correction`. This enables browser-based applications to produce higher-quality fitted curves by incorporating the original skeleton path as guidance.

## New API Exports

### WebSkeletonInfo
Represents a skeleton path with point type information for curve fitting.

```typescript
// Create skeleton from SVG path data
const skeleton = new WebSkeletonInfo(
    "M 0 0 L 100 100 L 200 0",  // SVG path string
    [0, 0, 0]                    // Point types: 0=Smooth, 1=Corner
);
```

### fit_curve_with_stroke_and_skeleton
Fits a stroked path with optional skeleton guidance, returning curve segments.

```typescript
const curveOptions = new CurveFitterOptions();
const strokeOptions = new StrokeOptions();
strokeOptions.set_width(10.0);

const skeleton = new WebSkeletonInfo("M 0 0 L 100 100 L 200 0", [0, 0, 0]);

// With skeleton correction (recommended)
const segments = fit_curve_with_stroke_and_skeleton(
    points,
    curveOptions,
    strokeOptions,
    skeleton  // Optional: pass undefined for outline-only refitting
);

// Without skeleton (fallback to outline-based)
const segmentsNoSkeleton = fit_curve_with_stroke_and_skeleton(
    points,
    curveOptions,
    strokeOptions,
    undefined
);
```

### curve_to_svg_path_with_stroke_and_skeleton
Fits a stroked path and returns an SVG path string.

```typescript
const svgPath = curve_to_svg_path_with_stroke_and_skeleton(
    points,
    curveOptions,
    strokeOptions,
    skeleton
);

console.log(svgPath);  // "M 10 10 C 20 20 30 30 40 40 ..."
```

## Usage Example

```javascript
import init, {
    WebPoint, WebSkeletonInfo, CurveFitterOptions, StrokeOptions,
    fit_curve_with_stroke_and_skeleton
} from './pkg/web_demo.js';

async function main() {
    await init();
    
    // Create input points for curve fitting
    const points = [];
    for (let i = 0; i < 5; i++) {
        const pt = new WebPoint(i * 50, Math.sin(i) * 50);
        points.push(pt);
    }
    
    // Create skeleton path (the original control polygon)
    const skeletonPath = "M 0 0 L 50 0 L 100 0 L 150 0 L 200 0";
    const skeletonTypes = [0, 0, 0, 0, 0];  // All smooth points
    const skeleton = new WebSkeletonInfo(skeletonPath, skeletonTypes);
    
    // Configure options
    const curveOpts = new CurveFitterOptions();
    curveOpts.set_cyclic(false);
    
    const strokeOpts = new StrokeOptions();
    strokeOpts.set_width(10.0);
    
    // Fit curve with skeleton correction
    const segments = fit_curve_with_stroke_and_skeleton(
        points,
        curveOpts,
        strokeOpts,
        skeleton
    );
    
    // Use the segments (draw to canvas, etc.)
    renderSegments(segments);
}

main().catch(console.error);
```

## Architecture

### Helper Functions

**parse_svg_path(path_data: &str) -> Result<BezPath>**
- Parses SVG path strings into internal BezPath representation
- Supports M, L, Q, C, and Z path commands

**skeleton_path_to_input_points(...) -> Result<Vec<InputPoint>>**
- Extracts on-curve points from skeleton path
- Maps point types (Smooth/Corner) from WebSkeletonInfo
- Returns InputPoints with extracted geometry

### Data Flow

```
User Input (WebPoint[])
       ↓
Fit initial curve (fit_curve)
       ↓
Apply stroke (variable-width or constant)
       ↓
┌──────────────────────────────────────────┐
│ If skeleton provided:                    │
│  1. Parse SVG skeleton path              │
│  2. Extract skeleton points & types      │
│  3. Register skeleton for preservation   │
│  4. Apply refit_stroke_with_skeleton_correction
│  5. Fallback to outline refitting on error
└──────────────────────────────────────────┘
       ↓
Return segments or SVG path
```

## Error Handling

The functions gracefully handle errors with fallback strategies:

1. **Skeleton parsing fails** → Use outline refitting
2. **Skeleton registration fails** → Use outline refitting
3. **Skeleton-aware refitting fails** → Use outline refitting
4. **Outline refitting fails** → Return original stroke outline

All errors are logged to the browser console with helpful messages.

## Performance Considerations

- **Skeleton overhead**: ~10-20% slower with skeleton vs outline-only
- **WASM bundle size**: ~234KB (web_demo_bg.wasm)
- **Suitable for**: Interactive web applications, font design tools, drawing apps
- **Not suitable for**: Real-time heavy computation

## Browser Compatibility

Requires WebAssembly support:
- Chrome/Edge: 57+
- Firefox: 52+
- Safari: 14.1+
- Opera: 44+

## Type Definitions

Full TypeScript definitions are auto-generated by wasm-bindgen:

```typescript
// From web_demo.d.ts
export class WebSkeletonInfo {
    constructor(path_data: string, point_types: Uint32Array);
    path_data(): string;
    point_types(): Uint32Array;
}

export function fit_curve_with_stroke_and_skeleton(
    points: WebPoint[],
    curve_options: CurveFitterOptions,
    stroke_options: StrokeOptions,
    skeleton_info?: WebSkeletonInfo | null
): CurveSegment[];

export function curve_to_svg_path_with_stroke_and_skeleton(
    points: WebPoint[],
    curve_options: CurveFitterOptions,
    stroke_options: StrokeOptions,
    skeleton_info?: WebSkeletonInfo | null
): string;
```

## Console Logging

The functions use console.log for debugging. Check browser DevTools console for:
- Skeleton parsing status
- Point extraction counts
- Skeleton registration results
- Refitting pipeline decisions
- Error messages with full details

Example output:
```
Stroke refitted with skeleton correction: 48 → 32 elements
Corrected misclassified corners: 1 detected, 1 corrected, 0 unmatched
```

## Building for Production

The WASM module is already built in `web-demo/pkg/`. To rebuild after code changes:

```bash
cd web-demo
./build.sh
```

This generates:
- `web_demo_bg.wasm` - Compiled WebAssembly module
- `web_demo.js` - JavaScript bindings and glue code
- `web_demo.d.ts` - TypeScript type definitions
- `package.json` - NPM package metadata
